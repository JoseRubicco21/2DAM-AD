package com.postgres.services.database.schema.annotations;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import com.postgres.annotations.Column;
import com.postgres.annotations.Table;
import com.postgres.services.database.query_builder.QueryBuilder;
import com.postgres.services.database.query_builder.QueryBuilderFactory;
import com.postgres.services.logger.Logger;

public class AnnotationSchemaBuilder {
    
    private final String sqlFlavor;
    
    public AnnotationSchemaBuilder(String sqlFlavor) {
        this.sqlFlavor = sqlFlavor;
    }
    
    /**
     * Creates a QueryBuilder based on the SQL flavor
     * @return QueryBuilder instance for the specified dialect
     */
    private QueryBuilder createQueryBuilder() {
        switch (sqlFlavor.toLowerCase()) {
            case "postgresql":
            case "postgres":
                return QueryBuilderFactory.createPostgreSQL();
            case "mysql":
            case "mariadb":
            default:
                return QueryBuilderFactory.createMySQL();
        }
    }
    
    public PreparedStatement createTableStatement(Class<?> modelClass, Connection connection) throws SQLException {
        // Read the @Table annotation
        Table tableAnnotation = modelClass.getAnnotation(Table.class);
        if (tableAnnotation == null) {
            throw new IllegalArgumentException("Class " + modelClass.getSimpleName() + " is not annotated with @Table");
        }
        String tableName = tableAnnotation.name();
        
        Logger.info("Creating table for: " + modelClass.getSimpleName() + " -> " + tableName);
        Logger.info("Using SQL flavor: " + sqlFlavor);
        
        QueryBuilder qbColumns = createQueryBuilder();
        
        // Get all fields with @Column annotations
        Field[] fields = modelClass.getDeclaredFields();
        boolean first = true;
        
        for (Field field : fields) {
            Column column = field.getAnnotation(Column.class);
            if (column != null) {
                Logger.info("Processing field: " + field.getName() + 
                           " | primaryKey=" + column.primaryKey() + 
                           " | autoIncrement=" + column.autoIncrement() + 
                           " | type=" + column.type());
                
                if (!first) qbColumns.INPUT(", ");
                
                // Column name
                qbColumns.INPUT(column.name()).INPUT(" ");
                
                // Handle PostgreSQL SERIAL type for auto-increment integer primary keys
                if (isPostgreSQL() && column.primaryKey() && column.autoIncrement() && 
                    (column.type().equalsIgnoreCase("INT") || column.type().equalsIgnoreCase("INTEGER"))) {
                    
                    Logger.info("Using SERIAL for: " + column.name());
                    qbColumns.INPUT("SERIAL PRIMARY KEY");
                    
                } else {
                    // Handle regular data type with length
                    if (column.length() > 0) {
                        qbColumns.INPUT(column.type() + "(" + column.length() + ")");
                    } else {
                        qbColumns.INPUT(column.type());
                    }
                    
                    // Add constraints in proper order
                    if (column.primaryKey()) {
                        qbColumns.INPUT(" PRIMARY KEY");
                    }
                    
                    if (column.autoIncrement() && !isPostgreSQL()) {
                        // MySQL/MariaDB auto increment
                        qbColumns.INPUT(" AUTO_INCREMENT");
                    } else if (column.autoIncrement() && isPostgreSQL() && !column.primaryKey()) {
                        // PostgreSQL auto increment for non-primary key (use IDENTITY)
                        qbColumns.INPUT(" GENERATED BY DEFAULT AS IDENTITY");
                    }
                    
                    if (column.unique() && !column.primaryKey()) {
                        qbColumns.INPUT(" UNIQUE");
                    }
                    
                    if (!column.nullable()) {
                        qbColumns.INPUT(" NOT NULL");
                    }
                }
                
                first = false;
            }
        }
        
        // Build final query manually to ensure correct syntax
        String columnsDefinition = qbColumns.CONSUME();
        String finalQuery;
        
        if (isPostgreSQL()) {
            finalQuery = "CREATE TABLE IF NOT EXISTS " + tableName + " (" + columnsDefinition + ")";
        } else {
            finalQuery = "CREATE TABLE IF NOT EXISTS " + tableName + " (" + columnsDefinition + ")";
        }
        
        Logger.query("Generated CREATE TABLE query: " + finalQuery);
        return connection.prepareStatement(finalQuery);
    }
    
    public PreparedStatement dropTableStatement(Class<?> modelClass, Connection connection) throws SQLException {
        Table tableAnnotation = modelClass.getAnnotation(Table.class);
        if (tableAnnotation == null) {
            throw new IllegalArgumentException("Class " + modelClass.getSimpleName() + " is not annotated with @Table");
        }
        
        String query = "DROP TABLE IF EXISTS " + tableAnnotation.name();
        Logger.query("Dropping table (" + sqlFlavor + "): " + query);
        return connection.prepareStatement(query);
    }
    
    /**
     * Helper method to check if we're using PostgreSQL dialect
     * @return true if using PostgreSQL
     */
    private boolean isPostgreSQL() {
        return sqlFlavor.toLowerCase().equals("postgresql") || 
               sqlFlavor.toLowerCase().equals("postgres");
    }
    
    /**
     * Helper method to check if we're using MySQL dialect
     * @return true if using MySQL/MariaDB
     */
    private boolean isMySQL() {
        return sqlFlavor.toLowerCase().equals("mysql") || 
               sqlFlavor.toLowerCase().equals("mariadb");
    }
}